了解！以下は **2部構成** です。
A) すぐ動かせる **FastAPI ひな型コード**（PDF抽出 / Gemini / Auth0 / Firestore）
B) Cursor に貼るだけで使える **SpecKit風プロンプト**（Mantine 採択）

---

# A) FastAPI ひな型コード（Python, 別ランタイムAPI, モノレポ前提）

> 公式の用法に沿った Gemini / Auth0 / Firestore / Mantine の参照も付けています。Gemini の Python SDK は `google-generativeai` 系の実装を想定しています（`GenerativeModel("gemini-1.5-pro")` など）。([Google AI for Developers][1])
> Auth0 の RS256/JWKS 検証フローの実装手順は公式ブログを参照。([Auth0][2], [alukach.com][3])
> Firestore クライアントの使い方は公式リファレンス。([Google Cloud][4], [GitHub][5])
> PDF 抽出は `pdfplumber` を採用。([GitHub][6], [Unstract.com →][7])
> フロント UI は Mantine ドキュメントを参照。([mantine.dev][8])

## 1) ディレクトリ（モノレポ例）

```
/uteach
  /frontend         # React + Mantine
  /backend          # FastAPI (Python)
  /shared           # 型/プロンプト/仕様
  package.json      # ルートスクリプト（lint 等）
  README.md
```

## 2) backend/requirements.txt

```
fastapi==0.115.0
uvicorn[standard]==0.30.6
python-multipart==0.0.9
pydantic==2.8.2
requests==2.32.3
beautifulsoup4==4.12.3
pdfplumber==0.11.4
google-generativeai==0.7.2
google-cloud-firestore==2.17.0
python-jose[cryptography]==3.3.0
```

## 3) backend/main.py

```python
from fastapi import FastAPI, UploadFile, File, Depends, HTTPException, Body
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel
from typing import List, Optional
from io import BytesIO
import pdfplumber
import requests
from bs4 import BeautifulSoup
import os, json, time

# --- Auth0 JWKS 検証 ---
from jose import jwt
from jose.utils import base64url_decode

AUTH0_DOMAIN = os.getenv("AUTH0_DOMAIN")                   # e.g. "your-tenant.eu.auth0.com"
AUTH0_AUDIENCE = os.getenv("AUTH0_AUDIENCE")               # e.g. "https://api.uteach"
AUTH0_ALG = "RS256"
JWKS_URL = f"https://{AUTH0_DOMAIN}/.well-known/jwks.json"

security = HTTPBearer()
_jwks_cache = {"keys": [], "fetched_at": 0}

def _get_jwks():
    # 5分キャッシュ
    if time.time() - _jwks_cache["fetched_at"] > 300:
        resp = requests.get(JWKS_URL, timeout=10)
        resp.raise_for_status()
        _jwks_cache["keys"] = resp.json()["keys"]
        _jwks_cache["fetched_at"] = time.time()
    return _jwks_cache["keys"]

def verify_jwt(credentials: HTTPAuthorizationCredentials = Depends(security)):
    token = credentials.credentials
    unverified_header = jwt.get_unverified_header(token)
    jwks = _get_jwks()
    rsa_key = {}
    for key in jwks:
        if key["kid"] == unverified_header.get("kid"):
            rsa_key = {
                "kty": key["kty"],
                "kid": key["kid"],
                "use": key["use"],
                "n": key["n"],
                "e": key["e"]
            }
            break
    if not rsa_key:
        raise HTTPException(status_code=401, detail="Invalid header")

    payload = jwt.decode(
        token,
        rsa_key,
        algorithms=[AUTH0_ALG],
        audience=AUTH0_AUDIENCE,
        issuer=f"https://{AUTH0_DOMAIN}/"
    )
    return payload  # {sub, scope, ...}

# --- Firestore ---
from google.cloud import firestore
db = firestore.Client()   # GOOGLE_APPLICATION_CREDENTIALS を設定

# --- Gemini ---
import google.generativeai as genai
genai.configure(api_key=os.getenv("GEMINI_API_KEY"))
GEMINI_MODEL = os.getenv("GEMINI_MODEL", "gemini-1.5-pro")

# --- FastAPI ---
app = FastAPI(title="UTeach API", version="0.1.0")
app.add_middleware(
    CORSMiddleware,
    allow_origins=os.getenv("CORS_ORIGINS", "*").split(","),
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- モデル ---
class UploadURL(BaseModel):
    url: str
    title: Optional[str] = None

class GenerateReq(BaseModel):
    material_id: str
    level: str = "beginner"  # beginner | intermediate | advanced
    num_questions: int = 5

class AnswerReq(BaseModel):
    session_id: str
    question_id: str
    answer_text: str

# --- ユーティリティ ---
def chunk_text(text: str, chunk_size: int = 2800) -> List[str]:
    # ざっくり文字数分割（実運用では token ベース推奨）
    return [text[i:i+chunk_size] for i in range(0, len(text), chunk_size)]

def extract_text_from_pdf(file_bytes: bytes) -> str:
    out = []
    with pdfplumber.open(BytesIO(file_bytes)) as pdf:
        for page in pdf.pages:
            out.append(page.extract_text() or "")
    return "\n".join(out)

def extract_text_from_url(url: str) -> str:
    r = requests.get(url, timeout=15)
    r.raise_for_status()
    soup = BeautifulSoup(r.text, "html.parser")
    # 最低限の抽出（必要なら Readability 等に差し替え）
    for t in soup(["script", "style", "header", "footer", "nav"]):
        t.extract()
    text = " ".join(soup.get_text(separator=" ").split())
    return text

def gemini_student_questions(context: str, level: str, n: int):
    model = genai.GenerativeModel(GEMINI_MODEL)
    sys = (
        "You are a curious student AI in a tutoring app. "
        "Read the provided study material and generate ONLY JSON: "
        '{"questions":[{"id":"q1","question":"..."},{"id":"q2","question":"..."}]} '
        f"Level: {level}. Ask {n} concise, level-appropriate questions. No prose."
    )
    # safetyやJSON指定は Gemini 側の機能に合わせて調整可
    resp = model.generate_content([sys, context])
    text = resp.text.strip()
    # JSONパース失敗時のフォールバック
    try:
        data = json.loads(text)
        return data["questions"]
    except Exception:
        # 箇条書きから復元
        lines = [l.strip("-• ").strip() for l in text.splitlines() if l.strip()]
        return [{"id": f"q{i+1}", "question": l} for i, l in enumerate(lines[:n])]

def gemini_teacher_feedback(question: str, answer: str, context: str):
    model = genai.GenerativeModel(GEMINI_MODEL)
    sys = (
        "You are a teaching assistant. Evaluate the teacher's explanation to a student question. "
        "Return ONLY JSON with keys: {\"score\":0-100,\"strengths\":[],\"suggestions\":[],\"model_answer\":\"...\"}."
    )
    prompt = f"# Question\n{question}\n\n# TeacherAnswer\n{answer}\n\n# Context\n{context[:4000]}"
    resp = model.generate_content([sys, prompt])
    try:
        return json.loads(resp.text)
    except Exception:
        return {"score": 70, "strengths": [], "suggestions": [resp.text[:500]], "model_answer": ""}

# --- エンドポイント ---

@app.post("/upload/pdf")
async def upload_pdf(file: UploadFile = File(...), user=Depends(verify_jwt)):
    content = await file.read()
    text = extract_text_from_pdf(content)
    doc = db.collection("materials").document()
    doc.set({
        "owner": user["sub"],
        "title": file.filename,
        "type": "pdf",
        "content": text,
        "createdAt": firestore.SERVER_TIMESTAMP
    })
    return {"material_id": doc.id, "chars": len(text)}

@app.post("/upload/url")
async def upload_url(body: UploadURL, user=Depends(verify_jwt)):
    text = extract_text_from_url(body.url)
    doc = db.collection("materials").document()
    doc.set({
        "owner": user["sub"],
        "title": body.title or body.url,
        "type": "url",
        "url": body.url,
        "content": text,
        "createdAt": firestore.SERVER_TIMESTAMP
    })
    return {"material_id": doc.id, "chars": len(text)}

@app.post("/materials/generate-questions")
async def generate_questions(req: GenerateReq, user=Depends(verify_jwt)):
    mat = db.collection("materials").document(req.material_id).get()
    if not mat.exists or mat.to_dict().get("owner") != user["sub"]:
        raise HTTPException(404, "material not found")
    context = mat.to_dict()["content"]
    questions = gemini_student_questions(context, req.level, req.num_questions)
    sess = db.collection("sessions").document()
    sess.set({
        "owner": user["sub"],
        "material_id": req.material_id,
        "level": req.level,
        "questions": questions,
        "createdAt": firestore.SERVER_TIMESTAMP
    })
    return {"session_id": sess.id, "questions": questions}

@app.post("/sessions/answer")
async def submit_answer(req: AnswerReq, user=Depends(verify_jwt)):
    sess_ref = db.collection("sessions").document(req.session_id)
    sess = sess_ref.get()
    if not sess.exists or sess.to_dict().get("owner") != user["sub"]:
        raise HTTPException(404, "session not found")
    mat = db.collection("materials").document(sess.to_dict()["material_id"]).get()
    context = mat.to_dict().get("content", "") if mat.exists else ""
    # 対象質問の本文
    question_text = next((q["question"] for q in sess.to_dict()["questions"] if q["id"] == req.question_id), "")
    feedback = gemini_teacher_feedback(question_text, req.answer_text, context)
    # Firestore 追記
    sess_ref.collection("answers").add({
        "question_id": req.question_id,
        "answer_text": req.answer_text,
        "feedback": feedback,
        "createdAt": firestore.SERVER_TIMESTAMP
    })
    return {"feedback": feedback}

@app.get("/history")
async def history(user=Depends(verify_jwt)):
    q = db.collection("sessions").where("owner", "==", user["sub"]).order_by("createdAt", direction=firestore.Query.DESCENDING).limit(20).stream()
    out = []
    for doc in q:
        d = doc.to_dict()
        out.append({"session_id": doc.id, "material_id": d["material_id"], "level": d["level"], "questions": d.get("questions", [])})
    return {"sessions": out}
```

## 4) .env（APIランタイム）

```
AUTH0_DOMAIN=your-tenant.eu.auth0.com
AUTH0_AUDIENCE=https://api.uteach
GEMINI_API_KEY=your-google-api-key
GEMINI_MODEL=gemini-1.5-pro
GOOGLE_APPLICATION_CREDENTIALS=/path/to/service-account.json
CORS_ORIGINS=http://localhost:5173
```

## 5) 起動

```bash
cd backend
uvicorn main:app --reload --port 8787
```

---

# B) Cursor 向け「SpecKit風」プロンプト（そのまま貼り付けOK）

> **使い方**: 下記ブロックを Cursor に貼る → 指示に従って scaffolding。
> フロントは Mantine 採択、バックエンドは上記 FastAPI を参照。UI の最低限ページも定義済み。

```yaml
# == SpecKit Prompt: UTeach ==
project:
  name: UTeach
  description: "教える体験で学びを深める。ユーザー=先生 / AI=生徒。PDF/URLを読むAI生徒が質問し、ユーザーが説明・指導する。"

monorepo:
  layout:
    - frontend: "React + Vite + TypeScript + Mantine"
    - backend: "FastAPI(Python), Gemini, Firestore, Auth0(JWT)"
    - shared: "型/定数/プロンプト"
  scripts:
    root:
      - name: "format"
        run: "prettier -w ."
    frontend:
      - name: "dev"
        run: "vite"
      - name: "build"
        run: "vite build"
    backend:
      - name: "dev"
        run: "uvicorn main:app --reload --port 8787"

stack:
  ui: "Mantine (@mantine/core @mantine/hooks)"
  auth: "Auth0 (SPA, RS256, audience=https://api.uteach)"
  db: "Firestore"
  llm: "Gemini (gemini-1.5-pro)"
  pdf: "pdfplumber"
  lang: ["TypeScript", "Python 3.11+"]

env:
  frontend:
    - AUTH0_DOMAIN
    - AUTH0_CLIENT_ID
    - AUTH0_AUDIENCE="https://api.uteach"
    - API_BASE_URL="http://localhost:8787"
  backend:
    - AUTH0_DOMAIN
    - AUTH0_AUDIENCE
    - GEMINI_API_KEY
    - GEMINI_MODEL="gemini-1.5-pro"
    - GOOGLE_APPLICATION_CREDENTIALS
    - CORS_ORIGINS="http://localhost:5173"

routing_frontend:
  base: "/"
  pages:
    - path: "/login"
      name: "Login"
      purpose: "Auth0 Universal Loginへ誘導、サインイン"
    - path: "/dashboard"
      name: "Dashboard"
      purpose: "最近の教材とセッション履歴"
    - path: "/upload"
      name: "Upload"
      purpose: "PDF/URLの投入フォーム"
    - path: "/teach/:sessionId?"
      name: "Teach"
      purpose: "AI生徒の質問に回答、フィードバック確認"
    - path: "/history"
      name: "History"
      purpose: "過去セッション一覧・再開"

ui_components_mantine:
  atoms:
    - Button, TextInput, FileInput, SegmentedControl, Badge, Loader, Alert
  molecules:
    - "QuestionCard: AIの質問、レベル、進捗を表示"
    - "AnswerEditor: Markdownテキストエリア + 送信"
    - "FeedbackPanel: スコア/強み/改善提案を表示"
  layout:
    - "AppShell + Navbar (Dashboard/Upload/Teach/History)"
    - "Theme: dark base, primary=blue"

backend_api:
  base_url: "http://localhost:8787"
  endpoints:
    - method: POST
      path: /upload/pdf
      auth: "Bearer (Auth0)"
      body: "multipart/form-data(file)"
      returns: "{ material_id, chars }"
    - method: POST
      path: /upload/url
      auth: "Bearer (Auth0)"
      body: "{ url, title? }"
      returns: "{ material_id, chars }"
    - method: POST
      path: /materials/generate-questions
      auth: "Bearer (Auth0)"
      body: "{ material_id, level, num_questions }"
      returns: "{ session_id, questions[] }"
    - method: POST
      path: /sessions/answer
      auth: "Bearer (Auth0)"
      body: "{ session_id, question_id, answer_text }"
      returns: "{ feedback }"
    - method: GET
      path: /history
      auth: "Bearer (Auth0)"
      returns: "{ sessions: [...] }"

data_models:
  Question:
    id: string
    question: string
  Feedback:
    score: number # 0..100
    strengths: string[]
    suggestions: string[]
    model_answer: string
  Session:
    session_id: string
    material_id: string
    level: "beginner" | "intermediate" | "advanced"
    questions: Question[]

acceptance_criteria:
  - "PDF/URLアップロード後、/materials/generate-questions で質問がN件返る"
  - "Teach画面でユーザー回答を送信すると、score(0..100)とsuggestions[]が表示される"
  - "History画面で直近20セッションが見える"
  - "全リクエストにAuth0のJWTが必須（未認証は401）"
  - "APIエラー時はMantineのAlertで通知"

frontend_tasks:
  - "Auth0 React SDK導入（token取得、getAccessTokenSilently）"
  - "Mantine AppShell/Routes実装"
  - "Upload: FileInput と URL 入力、API 呼び出し"
  - "Teach: 左=質問リスト、中央=回答エディタ、右=フィードバック"
  - "History: セッション一覧"

backend_tasks:
  - "FastAPI 起動、CORS設定"
  - "Auth0 RS256/JWKS 検証依存を作成"
  - "PDF/URL抽出 + Firestore 保存"
  - "Gemini 連携: 生徒質問のJSON生成 / 教師回答の評価JSON生成"
  - "Firestore の sessions/answers への保存"

notes:
  - "テキスト分割はまずは文字数ベース、将来はトークンベースに改善"
  - "URL抽出は BeautifulSoup ベース。必要に応じて Readability に置換"
  - "Geminiプロンプトは JSON 返却を強制し、パース失敗時フォールバックあり"
```

---

## 参考（公式ドキュメント）

* Gemini API Cookbook（Python サンプル多数）。([Google AI for Developers][1])
* Auth0 × FastAPI 公式ブログ（RS256/JWKS 検証）。([Auth0][2])
* FastAPI/JWT の実装解説（補助参考）。([alukach.com][3], [FastAPI][9])
* Firestore Python クライアント。([Google Cloud][4], [GitHub][5])
* pdfplumber（PDFテキスト抽出ライブラリ）。([GitHub][6], [Unstract.com →][7])
* Mantine（導入・コアコンポーネント）。([mantine.dev][8])

---

必要なら、\*\*Mantine のページ雛形（Vite, Auth0 SDK 組み込み）\*\*も続けて用意します。フロントの最小実装まで一気にいきます？

[1]: https://ai.google.dev/gemini-api/cookbook?utm_source=chatgpt.com "Gemini API cookbook - Google AI for Developers"
[2]: https://auth0.com/blog/build-and-secure-fastapi-server-with-auth0/?utm_source=chatgpt.com "Build and Secure a FastAPI Server with Auth0"
[3]: https://alukach.com/posts/fastapi-rs256-jwt/?utm_source=chatgpt.com "Securing FastAPI with JWKS (AWS Cognito, Auth0)"
[4]: https://cloud.google.com/python/docs/reference/firestore/latest?utm_source=chatgpt.com "Python client library | Google Cloud"
[5]: https://github.com/googleapis/python-firestore?utm_source=chatgpt.com "GitHub - googleapis/python-firestore"
[6]: https://github.com/jsvine/pdfplumber?utm_source=chatgpt.com "pdfplumber - GitHub"
[7]: https://unstract.com/blog/guide-to-pdfplumber-text-and-table-extraction-capabilities/?utm_source=chatgpt.com "pdfplumber: A Guide to PDF Text and Table Extraction"
[8]: https://mantine.dev/getting-started/?utm_source=chatgpt.com "Getting started | Mantine"
[9]: https://fastapi.tiangolo.com/tutorial/security/oauth2-jwt/?utm_source=chatgpt.com "OAuth2 with Password (and hashing), Bearer with JWT tokens - FastAPI"