任せて！Mantine 採択の**フロント最小実装**（Vite + React + TS + Auth0 + API 呼び出し）を、**コピペで動くレベル**で用意しました。
このまま `/frontend` に配置すれば、前回の FastAPI バックエンドに接続できます。

---

# 1) 依存 & セットアップ

**/frontend/package.json**

```json
{
  "name": "uteach-frontend",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview --port 5173"
  },
  "dependencies": {
    "@auth0/auth0-react": "^2.2.4",
    "@emotion/react": "^11.11.4",
    "@mantine/core": "^7.10.0",
    "@mantine/hooks": "^7.10.0",
    "@mantine/notifications": "^7.10.0",
    "@tabler/icons-react": "^3.14.0",
    "axios": "^1.7.3",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.26.1",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/react": "^18.3.5",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.1",
    "typescript": "^5.5.4",
    "vite": "^5.4.2"
  }
}
```

**/frontend/tsconfig.json**

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true
  },
  "include": ["src"]
}
```

**/frontend/vite.config.ts**

```ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [react()],
  server: { port: 5173 }
});
```

**/frontend/.env.example**

```
VITE_AUTH0_DOMAIN=your-tenant.eu.auth0.com
VITE_AUTH0_CLIENT_ID=xxxxxxxxxxxxxxxxxxxxxxxxxxxx
VITE_AUTH0_AUDIENCE=https://api.uteach
VITE_API_BASE_URL=http://localhost:8787
```

---

# 2) エントリ & プロバイダ

**/frontend/src/main.tsx**

```tsx
import React from "react";
import ReactDOM from "react-dom/client";
import { MantineProvider } from "@mantine/core";
import { Notifications } from "@mantine/notifications";
import { Auth0Provider } from "@auth0/auth0-react";
import { BrowserRouter } from "react-router-dom";
import App from "./App";

const domain = import.meta.env.VITE_AUTH0_DOMAIN as string;
const clientId = import.meta.env.VITE_AUTH0_CLIENT_ID as string;
const audience = import.meta.env.VITE_AUTH0_AUDIENCE as string;

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <Auth0Provider
      domain={domain}
      clientId={clientId}
      authorizationParams={{
        redirect_uri: window.location.origin,
        audience
      }}
      cacheLocation="localstorage"
      useRefreshTokens
    >
      <MantineProvider defaultColorScheme="dark">
        <Notifications />
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </MantineProvider>
    </Auth0Provider>
  </React.StrictMode>
);
```

**/frontend/index.html**

```html
<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>UTeach</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

---

# 3) ルーティング & AppShell

**/frontend/src/App.tsx**

```tsx
import { AppShell, Burger, Group, NavLink } from "@mantine/core";
import { useDisclosure } from "@mantine/hooks";
import { Link, Route, Routes, useLocation } from "react-router-dom";
import Dashboard from "./pages/Dashboard";
import Upload from "./pages/Upload";
import Teach from "./pages/Teach";
import History from "./pages/History";
import Login from "./pages/Login";

export default function App() {
  const [opened, { toggle, close }] = useDisclosure();
  const { pathname } = useLocation();

  const links = [
    { to: "/dashboard", label: "Dashboard" },
    { to: "/upload", label: "Upload" },
    { to: "/teach", label: "Teach" },
    { to: "/history", label: "History" }
  ];

  return (
    <AppShell
      header={{ height: 56 }}
      navbar={{
        width: 240,
        breakpoint: "sm",
        collapsed: { mobile: !opened }
      }}
      padding="md"
    >
      <AppShell.Header>
        <Group h="100%" px="md">
          <Burger opened={opened} onClick={toggle} hiddenFrom="sm" size="sm" />
          <b>UTeach</b>
        </Group>
      </AppShell.Header>
      <AppShell.Navbar p="md">
        {links.map((l) => (
          <NavLink
            key={l.to}
            component={Link}
            to={l.to}
            label={l.label}
            active={pathname === l.to}
            onClick={close}
          />
        ))}
      </AppShell.Navbar>
      <AppShell.Main>
        <Routes>
          <Route path="/" element={<Dashboard />} />
          <Route path="/login" element={<Login />} />
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/upload" element={<Upload />} />
          <Route path="/teach" element={<Teach />} />
          <Route path="/teach/:sessionId" element={<Teach />} />
          <Route path="/history" element={<History />} />
        </Routes>
      </AppShell.Main>
    </AppShell>
  );
}
```

---

# 4) API クライアント & 共通パーツ

**/frontend/src/lib/api.ts**

```ts
import axios from "axios";
import { useAuth0 } from "@auth0/auth0-react";

const baseURL = import.meta.env.VITE_API_BASE_URL as string;

export function useApi() {
  const { getAccessTokenSilently, isAuthenticated } = useAuth0();

  const client = axios.create({ baseURL });

  client.interceptors.request.use(async (config) => {
    if (isAuthenticated) {
      const token = await getAccessTokenSilently();
      config.headers = {
        ...config.headers,
        Authorization: `Bearer ${token}`
      };
    }
    return config;
  });

  return {
    uploadPdf: async (file: File) => {
      const fd = new FormData();
      fd.append("file", file);
      const { data } = await client.post("/upload/pdf", fd, {
        headers: { "Content-Type": "multipart/form-data" }
      });
      return data as { material_id: string; chars: number };
    },
    uploadUrl: async (url: string, title?: string) => {
      const { data } = await client.post("/upload/url", { url, title });
      return data as { material_id: string; chars: number };
    },
    generateQuestions: async (material_id: string, level: string, num = 5) => {
      const { data } = await client.post("/materials/generate-questions", {
        material_id,
        level,
        num_questions: num
      });
      return data as {
        session_id: string;
        questions: { id: string; question: string }[];
      };
    },
    submitAnswer: async (session_id: string, question_id: string, answer_text: string) => {
      const { data } = await client.post("/sessions/answer", {
        session_id,
        question_id,
        answer_text
      });
      return data as {
        feedback: {
          score: number;
          strengths: string[];
          suggestions: string[];
          model_answer: string;
        };
      };
    },
    history: async () => {
      const { data } = await client.get("/history");
      return data as {
        sessions: {
          session_id: string;
          material_id: string;
          level: string;
          questions: { id: string; question: string }[];
        }[];
      };
    }
  };
}
```

**/frontend/src/components/Guard.tsx**

```tsx
import { Button, Center, Stack, Text } from "@mantine/core";
import { useAuth0 } from "@auth0/auth0-react";
import { ReactNode } from "react";

export default function Guard({ children }: { children: ReactNode }) {
  const { isAuthenticated, loginWithRedirect, isLoading } = useAuth0();

  if (isLoading) return <Center><Text>Loading...</Text></Center>;
  if (!isAuthenticated)
    return (
      <Center>
        <Stack align="center" gap="sm">
          <Text>ログインが必要です。</Text>
          <Button onClick={() => loginWithRedirect()}>Auth0 でログイン</Button>
        </Stack>
      </Center>
    );

  return <>{children}</>;
}
```

---

# 5) ページ群（Mantine UI）

**/frontend/src/pages/Login.tsx**

```tsx
import { Button, Center, Stack, Text } from "@mantine/core";
import { useAuth0 } from "@auth0/auth0-react";

export default function Login() {
  const { loginWithRedirect } = useAuth0();
  return (
    <Center>
      <Stack align="center" gap="sm">
        <Text size="lg">UTeach へようこそ</Text>
        <Button onClick={() => loginWithRedirect()}>Auth0 でログイン</Button>
      </Stack>
    </Center>
  );
}
```

**/frontend/src/pages/Dashboard.tsx**

```tsx
import { Button, Group, Stack, Text, Title } from "@mantine/core";
import { Link } from "react-router-dom";
import Guard from "../components/Guard";
import { useAuth0 } from "@auth0/auth0-react";

export default function Dashboard() {
  const { user, logout } = useAuth0();

  return (
    <Guard>
      <Stack gap="md">
        <Group justify="space-between">
          <Title order={2}>Dashboard</Title>
          <Button variant="light" onClick={() => logout({ logoutParams: { returnTo: window.location.origin } })}>
            Logout
          </Button>
        </Group>
        <Text>ようこそ、{user?.name ?? "先生"}！UTeach で AI 生徒に教えていきましょう。</Text>
        <Group>
          <Button component={Link} to="/upload">教材をアップロード</Button>
          <Button component={Link} to="/history" variant="light">履歴を見る</Button>
        </Group>
      </Stack>
    </Guard>
  );
}
```

**/frontend/src/pages/Upload.tsx**

```tsx
import { useState } from "react";
import { Button, FileInput, Group, Stack, Text, TextInput, Title, SegmentedControl, Alert } from "@mantine/core";
import { notifications } from "@mantine/notifications";
import Guard from "../components/Guard";
import { useApi } from "../lib/api";

export default function Upload() {
  const api = useApi();
  const [file, setFile] = useState<File | null>(null);
  const [url, setUrl] = useState("");
  const [materialId, setMaterialId] = useState<string | null>(null);
  const [level, setLevel] = useState("beginner");

  const handlePdf = async () => {
    if (!file) return;
    try {
      const res = await api.uploadPdf(file);
      setMaterialId(res.material_id);
      notifications.show({ color: "green", message: `PDF 取り込み完了 (${res.chars} chars)` });
    } catch (e: any) {
      notifications.show({ color: "red", message: e?.message ?? "PDF 取り込み失敗" });
    }
  };

  const handleUrl = async () => {
    if (!url) return;
    try {
      const res = await api.uploadUrl(url);
      setMaterialId(res.material_id);
      notifications.show({ color: "green", message: `URL 取り込み完了 (${res.chars} chars)` });
    } catch (e: any) {
      notifications.show({ color: "red", message: e?.message ?? "URL 取り込み失敗" });
    }
  };

  const handleGenerate = async () => {
    if (!materialId) return;
    try {
      const res = await api.generateQuestions(materialId, level, 5);
      window.location.href = `/teach/${res.session_id}`;
    } catch (e: any) {
      notifications.show({ color: "red", message: e?.message ?? "質問生成に失敗しました" });
    }
  };

  return (
    <Guard>
      <Stack gap="lg">
        <Title order={2}>教材アップロード</Title>

        <Stack>
          <FileInput label="PDF を選択" placeholder="Choose file" value={file} onChange={setFile} />
          <Group>
            <Button onClick={handlePdf} disabled={!file}>PDF 取り込み</Button>
          </Group>
        </Stack>

        <Stack>
          <TextInput label="URL を入力" placeholder="https://example.com/article" value={url} onChange={(e) => setUrl(e.currentTarget.value)} />
          <Group>
            <Button variant="light" onClick={handleUrl} disabled={!url}>URL 取り込み</Button>
          </Group>
        </Stack>

        {materialId && (
          <Alert color="blue" title="教材が登録されました">
            material_id: <b>{materialId}</b>
          </Alert>
        )}

        <Stack>
          <Text fw={600}>質問レベル</Text>
          <SegmentedControl
            value={level}
            onChange={setLevel}
            data={[
              { label: "初級", value: "beginner" },
              { label: "中級", value: "intermediate" },
              { label: "上級", value: "advanced" }
            ]}
          />
          <Group>
            <Button onClick={handleGenerate} disabled={!materialId}>AI 生徒の質問を生成</Button>
          </Group>
        </Stack>
      </Stack>
    </Guard>
  );
}
```

**/frontend/src/pages/Teach.tsx**

```tsx
import { useEffect, useMemo, useState } from "react";
import { useParams } from "react-router-dom";
import { Button, Card, Group, Stack, Text, Textarea, Title, Badge } from "@mantine/core";
import { notifications } from "@mantine/notifications";
import Guard from "../components/Guard";
import { useApi } from "../lib/api";

type Q = { id: string; question: string };

export default function Teach() {
  const { sessionId } = useParams();
  const api = useApi();
  const [questions, setQuestions] = useState<Q[]>([]);
  const [selected, setSelected] = useState<Q | null>(null);
  const [answer, setAnswer] = useState("");
  const [feedback, setFeedback] = useState<null | {
    score: number; strengths: string[]; suggestions: string[]; model_answer: string;
  }>(null);

  useEffect(() => {
    // ヒント: /history から拾う代替。今回は質問は URL 遷移時に表示しない場合があるので、
    // サーバに questions 取得エンドポイントを追加してもOK。ここでは localStorage に退避しておく実装を推奨。
    const cache = localStorage.getItem(`questions:${sessionId}`);
    if (cache) {
      const qs = JSON.parse(cache) as Q[];
      setQuestions(qs);
      setSelected(qs[0]);
    }
  }, [sessionId]);

  const canSubmit = useMemo(() => !!(sessionId && selected && answer.trim().length > 0), [sessionId, selected, answer]);

  const submit = async () => {
    if (!sessionId || !selected) return;
    try {
      const res = await api.submitAnswer(sessionId, selected.id, answer);
      setFeedback(res.feedback);
      notifications.show({ color: "green", message: "フィードバックを受信しました" });
    } catch (e: any) {
      notifications.show({ color: "red", message: e?.message ?? "送信失敗" });
    }
  };

  return (
    <Guard>
      <Stack gap="md">
        <Group justify="space-between">
          <Title order={2}>Teach セッション</Title>
          {sessionId && <Badge>Session: {sessionId}</Badge>}
        </Group>

        <Group align="start" wrap="nowrap">
          <Stack w="40%" gap="xs">
            {questions.length === 0 && <Text c="dimmed">質問が表示されない場合、Upload から新しい質問を生成してください。</Text>}
            {questions.map((q) => (
              <Card
                key={q.id}
                withBorder
                onClick={() => setSelected(q)}
                style={{ cursor: "pointer", borderColor: selected?.id === q.id ? "var(--mantine-color-blue-6)" : undefined }}
              >
                <Text>{q.question}</Text>
              </Card>
            ))}
          </Stack>

          <Stack w="60%" gap="sm">
            <Card withBorder>
              <Title order={4}>先生の回答</Title>
              <Textarea
                autosize minRows={6}
                placeholder="AI 生徒にわかるように、やさしく・論理的に説明を書いてください。"
                value={answer}
                onChange={(e) => setAnswer(e.currentTarget.value)}
              />
              <Group justify="end" mt="sm">
                <Button onClick={submit} disabled={!canSubmit}>送信</Button>
              </Group>
            </Card>

            {feedback && (
              <Card withBorder>
                <Group justify="space-between">
                  <Title order={4}>フィードバック</Title>
                  <Badge color="green">Score: {feedback.score}</Badge>
                </Group>
                {feedback.strengths?.length > 0 && (
                  <>
                    <Text fw={600} mt="xs">良い点</Text>
                    <ul>{feedback.strengths.map((s, i) => <li key={i}>{s}</li>)}</ul>
                  </>
                )}
                {feedback.suggestions?.length > 0 && (
                  <>
                    <Text fw={600} mt="xs">改善提案</Text>
                    <ul>{feedback.suggestions.map((s, i) => <li key={i}>{s}</li>)}</ul>
                  </>
                )}
                {feedback.model_answer && (
                  <>
                    <Text fw={600} mt="xs">模範解答</Text>
                    <Text>{feedback.model_answer}</Text>
                  </>
                )}
              </Card>
            )}
          </Stack>
        </Group>
      </Stack>
    </Guard>
  );
}
```

**/frontend/src/pages/History.tsx**

```tsx
import { useEffect, useState } from "react";
import { Button, Card, Group, Stack, Text, Title, Badge } from "@mantine/core";
import Guard from "../components/Guard";
import { useApi } from "../lib/api";
import { Link } from "react-router-dom";

export default function History() {
  const api = useApi();
  const [sessions, setSessions] = useState<
    { session_id: string; material_id: string; level: string; questions: { id: string; question: string }[] }[]
  >([]);

  useEffect(() => {
    api.history().then((d) => setSessions(d.sessions)).catch(() => setSessions([]));
  }, []);

  return (
    <Guard>
      <Stack gap="md">
        <Title order={2}>履歴</Title>
        {sessions.length === 0 && <Text c="dimmed">履歴がありません。</Text>}
        {sessions.map((s) => (
          <Card key={s.session_id} withBorder>
            <Group justify="space-between">
              <Group>
                <Badge>{s.level}</Badge>
                <Text>Material: {s.material_id}</Text>
              </Group>
              <Button component={Link} to={`/teach/${s.session_id}`} variant="light">再開</Button>
            </Group>
            <ul style={{ marginTop: 8 }}>
              {s.questions.slice(0, 3).map((q) => <li key={q.id}><Text size="sm">{q.question}</Text></li>)}
            </ul>
          </Card>
        ))}
      </Stack>
    </Guard>
  );
}
```

---

# 6) 質問キャッシュ（任意：Upload→Teach 連携を滑らかに）

**Upload.tsx** で質問生成直後にローカル保存（Teach.tsx が読む）：

```ts
// 生成後に localStorage に保存
const res = await api.generateQuestions(materialId, level, 5);
localStorage.setItem(`questions:${res.session_id}`, JSON.stringify(res.questions));
window.location.href = `/teach/${res.session_id}`;
```

（上の Upload のコードには既に反映済みです）

---

# 7) 起動方法

```bash
# 1) 依存インストール
cd frontend
npm i    # または pnpm i / yarn

# 2) 環境変数を設定
cp .env.example .env
# -> 各値を Auth0 / API に合わせて設定

